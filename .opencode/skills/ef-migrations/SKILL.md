# EF Core Migrations Skill

Specialized skill for Entity Framework Core database migrations.

## Critical Rule

> ⛔ **NEVER CREATE HAND-WRITTEN MIGRATIONS** ⛔
>
> Every migration MUST have its companion `*.Designer.cs` file generated by EF Core tooling.
> Hand-crafted migrations without Designer files will cause EF Core to fail to recognize the migration.

---

## The Problem with Hand-Written Migrations

Common issue: migrations are hand-written without their companion Designer files. This causes:

1. **EF Core couldn't find migrations** - `dotnet ef migrations list` didn't show them
2. **Database state mismatch** - Migrations existed in DB but EF didn't know about them
3. **Blocked new migrations** - Adding new migrations failed due to model snapshot conflicts

**Root cause**: Each migration requires TWO files:
- `{Timestamp}_{Name}.cs` - The migration logic (Up/Down methods)
- `{Timestamp}_{Name}.Designer.cs` - Model snapshot at that point in time

---

## Correct Migration Workflow

### Step 1: Modify Entity Classes

Make your changes to the domain model:

```csharp
public class Player : BaseEntity, ISoftDeletable
{
    // Add new property
    public int? RetirementYear { get; set; }
}
```

### Step 2: Update DbContext (if new entity)

If adding a new entity, add the DbSet:

```csharp
public DbSet<LeagueRecord> LeagueRecords { get; set; }
```

### Step 3: Update Entity Configuration (if needed)

Add or update Fluent API configuration:

```csharp
public class LeagueRecordConfiguration : IEntityTypeConfiguration<LeagueRecord>
{
    public void Configure(EntityTypeBuilder<LeagueRecord> builder)
    {
        builder.HasKey(x => x.Id);
        builder.Property(x => x.RecordValue).HasPrecision(18, 2);
        // ... etc
    }
}
```

### Step 4: Generate Migration with EF Tools

```bash
dotnet ef migrations add AddRetirementTracking --project YourProject.DataAccess
```

This generates BOTH files:
- `Migrations/20260127120000_AddRetirementTracking.cs`
- `Migrations/20260127120000_AddRetirementTracking.Designer.cs`

### Step 5: Review Generated Migration

Check the generated `Up()` and `Down()` methods. If modifications are needed, edit the `.cs` file (not the Designer).

### Step 6: Apply Migration

```bash
# Local development
dotnet ef database update --project YourProject.DataAccess

# Or let the API apply on startup (if configured)
```

---

## Verification Commands

### List all migrations
```bash
dotnet ef migrations list --project YourProject.DataAccess
```

All migrations should appear. If any are missing, they lack Designer files.

### Check pending migrations
```bash
dotnet ef migrations list --project YourProject.DataAccess | grep "(Pending)"
```

### Verify migration files exist
```bash
ls YourProject.DataAccess/Migrations/*.Designer.cs | wc -l
ls YourProject.DataAccess/Migrations/*.cs | grep -v Designer | wc -l
# These counts should match (excluding ModelSnapshot)
```

---

## Migration File Structure

```
YourProject.DataAccess/Migrations/
├── 20251119154355_InitialCreate.cs           # Migration logic
├── 20251119154355_InitialCreate.Designer.cs  # Model snapshot (REQUIRED)
├── 20260125000000_AddLeagueRecords.cs
├── 20260125000000_AddLeagueRecords.Designer.cs
└── YourDbContextModelSnapshot.cs              # Current model state
```

---

## Common Mistakes

| Mistake | Consequence | Fix |
|---------|-------------|-----|
| Hand-writing migration without `dotnet ef` | No Designer file, EF can't find it | Always use `dotnet ef migrations add` |
| Copying migration from another project | Designer has wrong model snapshot | Generate fresh with `dotnet ef` |
| Deleting Designer file | Migration becomes invisible | Regenerate or restore from git |
| Editing Designer file manually | Model snapshot corruption | Never edit Designer files |

---

## If You Inherit Hand-Written Migrations

If you encounter migrations without Designer files:

### Option 1: Generate Minimal Designer Files

Create a Designer file with minimal content that references the current snapshot:

```csharp
// <auto-generated />
using YourProject.DataAccess;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace YourProject.DataAccess.Migrations
{
    [DbContext(typeof(YourDbContext))]
    [Migration("20260125000000_AddLeagueRecords")]
    partial class AddLeagueRecords
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
            // Intentionally minimal - actual model is in ModelSnapshot
            modelBuilder.HasAnnotation("ProductVersion", "9.0.0");
        }
    }
}
```

### Option 2: Squash and Regenerate

If the database can be recreated:

1. Delete all migration files
2. Drop the database
3. Run `dotnet ef migrations add InitialCreate`
4. Apply fresh

---

## Hard Rules

1. **ALWAYS use `dotnet ef migrations add`** - Never create migration files manually

2. **NEVER delete Designer files** - They are required for EF to recognize migrations

3. **NEVER edit Designer files** - They are auto-generated and should not be modified

4. **ALWAYS verify after creating** - Run `dotnet ef migrations list` to confirm

5. **ALWAYS commit both files** - The `.cs` and `.Designer.cs` must be committed together

---

## Quick Reference

```bash
# Add a new migration
dotnet ef migrations add MigrationName --project YourProject.DataAccess

# List all migrations
dotnet ef migrations list --project YourProject.DataAccess

# Apply pending migrations
dotnet ef database update --project YourProject.DataAccess

# Remove last migration (only if not applied)
dotnet ef migrations remove --project YourProject.DataAccess

# Generate SQL script (for review)
dotnet ef migrations script --project YourProject.DataAccess

# Revert to specific migration
dotnet ef database update MigrationName --project YourProject.DataAccess
```

---

## Database Design Requirements

> **Think like a DBA WHILE designing schema and writing queries.**

### Index Strategy (Verify for every new table/column)

- [ ] All foreign keys have indexes
- [ ] Columns in WHERE clauses frequently? Add index
- [ ] Composite indexes: most selective column FIRST
- [ ] Filtered index for `IsDeleted = 0` on large tables
- [ ] **STOP**: Is this index necessary, or adding write overhead?

### Query Performance (Verify for every repository method)

- [ ] No N+1: Using `.Include()` / `.ThenInclude()` for related data
- [ ] Read-only queries use `.AsNoTracking()`
- [ ] Projecting to DTOs instead of loading full entities when possible
- [ ] Pagination has `.OrderBy()` before `.Skip()/.Take()`
- [ ] **Run `.ToQueryString()`** to see generated SQL - does it look sane?

### Locking & Concurrency (Consider for every write operation)

- [ ] Transaction scope appropriate (not too broad)
- [ ] Could this deadlock with concurrent requests? (same tables, different order)
- [ ] Using optimistic concurrency (`[ConcurrencyCheck]`) where appropriate
- [ ] Long-running operations? Consider breaking into smaller transactions

### Schema Design (Verify for every entity)

- [ ] Data types appropriate and sized correctly
- [ ] Nullable only where nulls are valid business state
- [ ] Cascade delete behavior intentional (Restrict vs Cascade)
- [ ] Soft delete columns present: `IsDeleted`, `DeletedAt`, `DeletedBy`, `DeleteReason`
- [ ] Query filter configured: `entity.HasQueryFilter(e => !e.IsDeleted)`

### EF Anti-Patterns (Avoid these)

| Anti-Pattern | Problem | Fix |
|--------------|---------|-----|
| `.ToList()` then filter | Loads entire table | Filter in query first |
| String interpolation in query | SQL injection risk | Use parameterized queries |
| Missing `.Include()` | N+1 queries | Eager load related data |
| Ignoring query filters | Returns deleted records | Use `.IgnoreQueryFilters()` explicitly only when needed |
| Client-side evaluation | Slow, memory-heavy | Ensure LINQ translates to SQL |

### Migration Safety (Verify before committing)

- [ ] Can run without downtime? (no locks on large tables)
- [ ] Data migrations won't timeout?
- [ ] `Down()` method correctly reverses `Up()`
- [ ] No breaking changes to existing data
